{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "fd03d5a9-0fb8-4ae1-a13b-29f2a9ddf541",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2025-04-17 22:59:55.865 \n",
      "  \u001b[33m\u001b[1mWarning:\u001b[0m to view this Streamlit app on a browser, run it with the following\n",
      "  command:\n",
      "\n",
      "    streamlit run C:\\Users\\swamy\\anaconda3\\Lib\\site-packages\\ipykernel_launcher.py [ARGUMENTS]\n",
      "2025-04-17 22:59:55.876 Session state does not function when running a script without `streamlit run`\n",
      "2025-04-17 22:59:55.876 No runtime found, using MemoryCacheStorageManager\n"
     ]
    }
   ],
   "source": [
    "import streamlit as st\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import yfinance as yf\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "from sklearn.ensemble import RandomForestRegressor\n",
    "from sklearn.preprocessing import MinMaxScaler\n",
    "from sklearn import metrics\n",
    "\n",
    "from keras.models import Sequential\n",
    "from keras.layers import LSTM, Dense, Dropout\n",
    "from keras.optimizers import Adam\n",
    "\n",
    "# -------------------- Sidebar --------------------\n",
    "st.sidebar.title(\"Stock Forecasting Dashboard\")\n",
    "tickers = st.sidebar.multiselect(\"Select Stocks\", ['AAPL', 'MSFT', 'GOOGL', 'TSLA', 'NVDA'], default=['AAPL'])\n",
    "start_date = st.sidebar.date_input(\"Start Date\", pd.to_datetime(\"2015-01-01\"))\n",
    "end_date = st.sidebar.date_input(\"End Date\", pd.to_datetime(\"2023-12-31\"))\n",
    "model_type = st.sidebar.selectbox(\"Select Model\", [\"LSTM\", \"Random Forest\"])\n",
    "run_forecast = st.sidebar.button(\"Run Forecast\")\n",
    "\n",
    "# -------------------- Utility Functions --------------------\n",
    "@st.cache_data\n",
    "def fetch_data(ticker, start, end):\n",
    "    df = yf.download(ticker, start=start, end=end)\n",
    "    df = df[['Adj Close']].rename(columns={'Adj Close': 'Close'})\n",
    "    df.reset_index(inplace=True)\n",
    "    return df\n",
    "\n",
    "def preprocess(df):\n",
    "    df = df.iloc[1000:-60, :]\n",
    "    df.set_index('Date', inplace=True)\n",
    "    return df\n",
    "\n",
    "def create_lstm_data(data, time_step=60):\n",
    "    X, y = [], []\n",
    "    for i in range(time_step, len(data)):\n",
    "        X.append(data[i-time_step:i, 0])\n",
    "        y.append(data[i, 0])\n",
    "    return np.array(X), np.array(y)\n",
    "\n",
    "def create_lag_features(df, lags=[1, 2, 3]):\n",
    "    df_lagged = df.copy()\n",
    "    for lag in lags:\n",
    "        df_lagged[f'lag_{lag}'] = df_lagged['Close'].shift(lag)\n",
    "    df_lagged.dropna(inplace=True)\n",
    "    return df_lagged\n",
    "\n",
    "# -------------------- Main Logic --------------------\n",
    "if run_forecast:\n",
    "    for ticker in tickers:\n",
    "        st.header(f\"ðŸ“ˆ {ticker} Forecast - {model_type}\")\n",
    "        \n",
    "        df = fetch_data(ticker, start_date, end_date)\n",
    "        df = preprocess(df)\n",
    "        \n",
    "        if model_type == \"LSTM\":\n",
    "            scaler = MinMaxScaler(feature_range=(0, 1))\n",
    "            data_scaled = scaler.fit_transform(df[['Close']])\n",
    "\n",
    "            time_step = 60\n",
    "            train_size = int(len(data_scaled) * 0.8)\n",
    "            train_data = data_scaled[:train_size]\n",
    "            test_data = data_scaled[train_size - time_step:]\n",
    "\n",
    "            X_train, y_train = create_lstm_data(train_data, time_step)\n",
    "            X_test, y_test = create_lstm_data(test_data, time_step)\n",
    "\n",
    "            X_train = X_train.reshape((X_train.shape[0], X_train.shape[1], 1))\n",
    "            X_test = X_test.reshape((X_test.shape[0], X_test.shape[1], 1))\n",
    "\n",
    "            model = Sequential([\n",
    "                LSTM(50, return_sequences=True, input_shape=(time_step, 1)),\n",
    "                Dropout(0.2),\n",
    "                LSTM(50),\n",
    "                Dropout(0.2),\n",
    "                Dense(1)\n",
    "            ])\n",
    "            model.compile(loss='mean_squared_error', optimizer=Adam())\n",
    "            model.fit(X_train, y_train, epochs=10, batch_size=32, verbose=0)\n",
    "\n",
    "            predicted = model.predict(X_test)\n",
    "            predicted_prices = scaler.inverse_transform(predicted)\n",
    "            actual_prices = scaler.inverse_transform(y_test.reshape(-1, 1))\n",
    "\n",
    "        elif model_type == \"Random Forest\":\n",
    "            df_rf = create_lag_features(df)\n",
    "            X = df_rf.drop('Close', axis=1)\n",
    "            y = df_rf['Close']\n",
    "\n",
    "            train_size = int(len(X) * 0.8)\n",
    "            X_train, X_test = X[:train_size], X[train_size:]\n",
    "            y_train, y_test = y[:train_size], y[train_size:]\n",
    "\n",
    "            model = RandomForestRegressor(n_estimators=100, random_state=42)\n",
    "            model.fit(X_train, y_train)\n",
    "\n",
    "            predicted_prices = model.predict(X_test)\n",
    "            actual_prices = y_test.values.reshape(-1, 1)\n",
    "            predicted_prices = predicted_prices.reshape(-1, 1)\n",
    "\n",
    "        # --- Evaluation ---\n",
    "        mae = metrics.mean_absolute_error(actual_prices, predicted_prices)\n",
    "        rmse = np.sqrt(metrics.mean_squared_error(actual_prices, predicted_prices))\n",
    "\n",
    "        # --- Plot ---\n",
    "        fig, ax = plt.subplots(figsize=(10, 5))\n",
    "        ax.plot(actual_prices, label='Actual')\n",
    "        ax.plot(predicted_prices, label='Predicted')\n",
    "        ax.set_title(f\"{ticker} Price Forecast ({model_type})\")\n",
    "        ax.set_xlabel(\"Days\")\n",
    "        ax.set_ylabel(\"Price (USD)\")\n",
    "        ax.legend()\n",
    "        st.pyplot(fig)\n",
    "\n",
    "        st.markdown(f\"**MAE:** {mae:.4f} &nbsp;&nbsp;&nbsp; **RMSE:** {rmse:.4f}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f60ddd98-f093-4d09-ab83-0185a254271c",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
